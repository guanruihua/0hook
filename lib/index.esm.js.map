{"version":3,"file":"index.esm.js","sources":["../node_modules/.pnpm/abandonjs@2.4.2/node_modules/abandonjs/lib/index.esm.js","../src/useSetState/index.tsx","../src/useCount/index.ts","../src/useBoolean/index.ts","../src/useObject/index.ts","../src/useMap/index.ts"],"sourcesContent":["/**\r\n * @title isArray\r\n * @description 是否为数组\r\n * @param value any\r\n * @returns boolean\r\n */\r\nconst isArray = Array.isArray;\n\nfunction type(param) {\r\n    const result = Object.prototype.toString\r\n        .call(param)\r\n        .match(/\\[object (\\w+)\\]/)[1];\r\n    if (result === 'Number' && isNaN(param))\r\n        return 'NaN';\r\n    return result;\r\n}\r\n/**\r\n * @title types\r\n * @description 获取类型数组\r\n * @param params any[] 待判断的参数列表\r\n * @param hasRepeat=false 保留重复类型\r\n * @return string[] 类型名称\r\n */\r\nfunction types(params, hasRepeat = false) {\r\n    const result = params.map(i => type(i)) || [];\r\n    if (hasRepeat) {\r\n        return result;\r\n    }\r\n    return [...new Set(result)];\r\n}\n\n/**\r\n * @title isFunction\r\n * @description 是否为普通函数\r\n * @param value {any}\r\n * @returns {boolean}\r\n */\r\nfunction isFunction(value) {\r\n    return type(value) === 'Function';\r\n}\r\n/**\r\n * @title isAsyncFunction\r\n * @description 是否为异步函数\r\n * @param value {any}\r\n * @returns {boolean}\r\n */\r\nfunction isAsyncFunction(value) {\r\n    return type(value) === 'AsyncFunction';\r\n}\r\n/**\r\n * @title likeFunction\r\n * @description 是否为函数\r\n * @param value {any}\r\n * @returns {boolean}\r\n */\r\nfunction likeFunction(value) {\r\n    return type(value) === 'Function' || type(value) === 'AsyncFunction';\r\n}\n\nconst INFINITY$1 = Infinity; // 无限\n\n/**\r\n * @title isEffectNumber\r\n * @description 是否为js的有效区间的数, 非number类型都为false\r\n * @param num any\r\n * @returns boolean\r\n */\r\nfunction isEffectNumber(num) {\r\n    if (type(num) === 'Number') {\r\n        if (num === INFINITY$1 || num === -INFINITY$1)\r\n            return false;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * @title isFloat\r\n * @description 判断数是否为浮点型\r\n * @param num 待检测的数据类型\r\n * @returns boolean\r\n */\r\nfunction isFloat(num) {\r\n    return (num % 1) !== 0;\r\n}\r\n/**\r\n * @title isNumber\r\n * @description 是否为数字\r\n * @param num 待检测的数据类型\r\n * @returns {boolean}\r\n */\r\nconst isNumber = (val) => type(val) === 'Number';\r\nconst isBigInt = (value) => type(value) === 'BigInt';\r\n/**\r\n * @title likeNumber\r\n * @description 是否为数字\r\n * @support: Number, NumberString\r\n * @unsupported: Infinity, Function\r\n * @param value any\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction likeNumber(value) {\r\n    if (type(value) === 'String') {\r\n        value = value.replaceAll(' ', '');\r\n    }\r\n    if ([Infinity, null, undefined, '', NaN].includes(value))\r\n        return false;\r\n    if (Array.isArray(value))\r\n        return false;\r\n    const result = type(value) === \"Number\" && typeof value === 'number';\r\n    if (result)\r\n        return result;\r\n    if (Number.isNaN(Number(value)) === false) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @title isObject\r\n * @description 判断是否为Object\r\n * @param value\r\n * @returns boolean\r\n */\r\nfunction isObject(value) {\r\n    return type(value) === 'Object';\r\n}\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isPromise = (value) => {\r\n    return type(value) === 'Promise';\r\n};\r\nconst toString$1$1 = Object.prototype.toString;\r\nconst isMap = (val) => toString$1$1.call(val) === '[object Map]';\r\nconst isSet = (val) => toString$1$1.call(val) === '[object Set]';\n\n/**\r\n * @title isString\r\n * @description 是否为字符串\r\n * @param value {any}\r\n * @returns {boolean}\r\n */\r\nfunction isString(value) {\r\n    return typeof value === 'string';\r\n}\r\n/**\r\n * @title isJsonString<T>\r\n * @description 判断是否为json字符串, 若是并返回处理后的对象\r\n * @param val 待判断字符串\r\n * @returns T | false\r\n */\r\nfunction isJsonString(val) {\r\n    if (typeof val !== 'string')\r\n        return false;\r\n    try {\r\n        const obj = JSON.parse(val);\r\n        return isObject(obj) && obj;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\n\n/**\r\n * @title isDate\r\n * @description 检查日期是否有效\r\n * @param date {any} 待判断日期\r\n * @returns {boolean}\r\n * @version 0.1.0\r\n */\r\nfunction isDate(date) {\r\n    return type(date) === 'Date';\r\n}\r\n/**\r\n * @title likeDate\r\n * @description 检查日期是否有效, 时间戳也为有效时间(13位/10位)\r\n * @param date {any}\r\n * @returns {boolean}\r\n */\r\nfunction likeDate(date) {\r\n    if (isDate(date))\r\n        return true;\r\n    if ((isString(date) && isNumber(Number(date)))\r\n        || isNumber(date)) {\r\n        if (date.toString().length === 13)\r\n            return true;\r\n        if (date.toString().length === 10)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * @title isTime\r\n * @description 检查日期是否有效, 时间戳也为有效时间(13位/10位)\r\n * @param time:any 待判断日期\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isTime(time) {\r\n    if (type(time) === 'Number') {\r\n        if (time.toString().length === 13)\r\n            return true;\r\n        if (time.toString().length === 10)\r\n            return true;\r\n    }\r\n    return time instanceof Date && !isNaN(time.getTime());\r\n}\n\n// RegExp\r\n/**\r\n * @title isEmpty\r\n * @description 判断是否为无效值 undefined , null, NaN\r\n * @param value any 待判断值\r\n * @returns boolean\r\n */\r\nfunction isEmpty(value) {\r\n    if (value === undefined || value === null || isNaN(value))\r\n        return true;\r\n    return false;\r\n}\r\n/**\r\n * @title FileTypeMap\r\n * @description 文件类型映射\r\n * @version 0.1.0\r\n */\r\nconst FileTypeMap = new Map([\r\n    ['Image', ['png', 'jpeg', 'jpg', 'png', 'bmp']],\r\n    ['Video', ['mp4', 'webm', 'ogg']],\r\n    ['PDF', ['pdf']],\r\n    ['Word', ['doc', 'docx']],\r\n    ['Excel', ['.xlsx', '.xls', '.csv']],\r\n]);\r\n/**\r\n * @title isFileExtension\r\n * @description 是否为指定字符串结尾\r\n * @param fileName string 文件名\r\n * @param list string[] 文件拓展名数组\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isFileExtension(fileName, list = []) {\r\n    if (typeof fileName !== 'string')\r\n        return false;\r\n    if (/\\.[a-zA-Z0-9]{1,}/.exec(fileName) === null)\r\n        return false;\r\n    if (list.length === 0)\r\n        return true;\r\n    const name = fileName.toLowerCase();\r\n    return list.some(i => name.endsWith(i) === true);\r\n}\r\n/**\r\n * @title isFile\r\n * @param fileName string\r\n * @param type {FileType}\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isFile(fileName, type) {\r\n    return isFileExtension(fileName, FileTypeMap.get(type));\r\n}\r\n/**\r\n * @title isImageFile\r\n * @param fileName string\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isImageFile(fileName) {\r\n    return isFileExtension(fileName, FileTypeMap.get('Image'));\r\n}\r\n/**\r\n * @title isVideoFile\r\n * @param fileName string\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isVideoFile(fileName) {\r\n    return isFileExtension(fileName, FileTypeMap.get('Video'));\r\n}\r\n/**\r\n * @title isPdfFile\r\n * @param fileName string\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isPdfFile(fileName) {\r\n    return isFileExtension(fileName, FileTypeMap.get('PDF'));\r\n}\r\n/**\r\n * @title isWordFile\r\n * @param fileName string\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isWordFile(fileName) {\r\n    return isFileExtension(fileName, FileTypeMap.get('Word'));\r\n}\r\n/**\r\n * @title isExcelFile\r\n * @param fileName string\r\n * @returns boolean\r\n * @version 0.1.0\r\n */\r\nfunction isExcelFile(fileName) {\r\n    return isFileExtension(fileName, FileTypeMap.get('Excel'));\r\n}\r\nconst isClient = typeof window !== 'undefined';\r\nconst isBoolean = (val) => typeof val === 'boolean';\r\nconst isWindow = (val) => typeof window !== 'undefined' && toString.call(val) === '[object Window]';\r\nconst isIOS =  isClient && window?.navigator?.userAgent && /iP(ad|hone|od)/.test(window.navigator.userAgent);\r\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\n\nconst MAX_VALUES_NUMBER = 1.7976931348623157e+308;\r\nconst MIN_VALUES_NUMBER = -1.7976931348623157e+308;\r\nconst INFINITY = Infinity; // 无限\n\n/**\r\n * @title toNumber\r\n * @description 将值转换为Number, 不可以正确装换的值, 均返回0\r\n * @param value any 待转换的数值\r\n * @returns number\r\n */\r\nfunction toNumber(value) {\r\n    if (type(value) === 'Number') {\r\n        if (value === INFINITY)\r\n            return MAX_VALUES_NUMBER;\r\n        if (value === -INFINITY)\r\n            return MIN_VALUES_NUMBER;\r\n        return value;\r\n    }\r\n    const result = +value;\r\n    if (type(result) === 'Number') {\r\n        return result;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * @title toFloat\r\n * @description 转换为指定位数的浮点数\r\n * @param num { number } 数字\r\n * @param fixed { number } 小数点位数\r\n * @returns { number }\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\r\nfunction toFloat(num, fixed = 1) {\r\n    return Number(num.toFixed(fixed));\r\n}\n\n/**\r\n * @title spLength\r\n * @description 指定长度\r\n * @param value any\r\n * @param min = 0\r\n * @param max number\r\n * @returns string\r\n */\r\nfunction spLength(value, min = 0, max) {\r\n    if (!/^[0-9]*$/.test(String(value))) {\r\n        return new Array(min).fill('0').join('');\r\n    }\r\n    const tmpValue = value.toString();\r\n    const len = tmpValue.length;\r\n    if (len > max) {\r\n        return tmpValue.slice(len - max);\r\n    }\r\n    if (len < min) {\r\n        return new Array(min - len).fill('0').join('') + tmpValue;\r\n    }\r\n    return tmpValue;\r\n}\r\n/**\r\n * @title getDecimal\r\n * @description 获取小数点位数\r\n * @param num { number }\r\n * @returns { number=0 }\r\n */\r\nfunction getDecimal(num) {\r\n    if (!isFloat(num))\r\n        return 0;\r\n    return num.toString().split('.')[1].length;\r\n}\r\n/**\r\n * @title clamp\r\n * @description 限制在lower和upper之间\r\n * @param num 待限制的值\r\n * @param lower 下限\r\n * @param upper 上限\r\n * @returns 返回被限制的值\r\n */\r\nfunction clamp(num, lower = -INFINITY, upper = INFINITY) {\r\n    if (num < lower)\r\n        return lower;\r\n    if (num > upper)\r\n        return upper;\r\n    return num;\r\n}\r\n/**\r\n * @title inRange\r\n * @description 判断是否在该范围\r\n * @param num 要检查的值\r\n * @param start=0 开始范围\r\n * @param end 结束范围(包含该值)\r\n * @returns boolean\r\n */\r\nfunction inRange(num, start = 0, end = MAX_VALUES_NUMBER) {\r\n    if (end < start)\r\n        return false;\r\n    if (num > end)\r\n        return false;\r\n    if (num < start)\r\n        return false;\r\n    return true;\r\n}\r\n/**\r\n * @title between\r\n * @description 判断值是否在两值之间\r\n * @param num number 待判断值\r\n * @param start=0 起始值\r\n * @param end number 结束值(不包含该值)\r\n * @returns boolean\r\n */\r\nfunction between(num, start = 0, end = MAX_VALUES_NUMBER) {\r\n    if (end < start)\r\n        return false;\r\n    if (num >= end)\r\n        return false;\r\n    if (num < start)\r\n        return false;\r\n    return true;\r\n}\r\n/**\r\n  * @title round\r\n  * @description数字四舍五入，保留n位小数\r\n  * @param number number 待处理数值\r\n  * @param n number = 0 四舍五入的位数\r\n  * @returns\r\n*/\r\nfunction round(number, n = 0) {\r\n    if (n <= 0)\r\n        return Math.round(number);\r\n    return Math.round(number * Math.pow(10, n)) / Math.pow(10, n);\r\n}\r\n/**\r\n * @title toThousands\r\n * @description 数字每千位加逗号\r\n * @param num string|number\r\n * @returns string\r\n */\r\nfunction toThousands(num) {\r\n    return num.toString().replace(/(\\d)(?=(\\d{3})+$)/g, '$1,');\r\n}\n\n/**\r\n * @title random\r\n * @description 随机数\r\n * @param lower { number } 下限\r\n * @param upper { number } 上限\r\n * @param floating { number = 0 } 是否返回浮点数(位数), 0: 整数\r\n */\r\nfunction random(lower = 0, upper = 1, floating = 0) {\r\n    if (lower === 0 && upper === 1) {\r\n        return Math.random();\r\n    }\r\n    if (isFloat(upper) || isFloat(lower)) {\r\n        const len = getDecimal(upper) > getDecimal(lower) ? getDecimal(upper) : getDecimal(lower);\r\n        if (floating === 0) {\r\n            floating = len;\r\n        }\r\n    }\r\n    const result = lower + Math.random() * (upper - lower);\r\n    if (floating)\r\n        return toFloat(result, floating);\r\n    return Math.ceil(result);\r\n}\r\n// 该方法用于获取两个整数之间的随机整数\r\n// const random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\r\n// random(1, 50);\n\n/**\r\n * @title replaces\r\n * @description 同时定义多个replace的规则使用\r\n * @param target {string}\r\n * @param regs {reg:RegExp|string,value:string}[]\r\n * @returns {string}\r\n */\r\nfunction replaces(target = '', regs = []) {\r\n    for (let i = 0; i < regs.length; i++) {\r\n        const { reg, value } = regs[i];\r\n        target = target.replace(reg, value);\r\n    }\r\n    return target;\r\n}\r\n/**\r\n * @title reverseString\r\n * @description 反转字符串\r\n * @param target string\r\n * @return string\r\n */\r\nfunction reverseString(target) {\r\n    return target.split('').reverse().join('');\r\n}\n\n/**\r\n * @title toString\r\n * @description 任意类型均可转换为string\r\n * @param value {any}\r\n * @returns {string}\r\n * @lastUpdate: 2.2.1\r\n */\r\nfunction toString$1(value) {\r\n    if (type(value) === 'String')\r\n        return value;\r\n    if ([\r\n        'Function', 'AsyncFunction', 'GeneratorFunction',\r\n        'Symbol', 'RegExp', 'Promise', 'Date', 'NaN',\r\n        'Map', 'Set', 'WeakMap', 'WeakSet', 'BigInt'\r\n    ].includes(type(value)))\r\n        return value.toString();\r\n    if (value === Infinity)\r\n        return 'Infinity';\r\n    if (value === -Infinity)\r\n        return '-Infinity';\r\n    if (value === undefined)\r\n        return 'undefined';\r\n    if (value === null)\r\n        return 'null';\r\n    return JSON.stringify(value);\r\n}\r\n/**\r\n * @title toStrings\r\n * @description 转换为字符串数组, 即数组的的项转换为数组\r\n * @param value {any[]}\r\n * @returns {string[]}\r\n */\r\nfunction toStrings(values) {\r\n    return values.map(i => toString$1(i));\r\n}\n\nfunction stringify(value, replacer, space) {\r\n    if (['Object', 'Array'].includes(type(value))) {\r\n        return JSON.stringify(value, replacer, space);\r\n    }\r\n    return JSON.stringify(toString$1(value), replacer, space)\r\n        .replace(/^(\")+|(\")+$/g, '');\r\n}\n\n/**\r\n * @title hide\r\n * @description 隐藏指定位置的字符\r\n * @param target {string} 待替换子串\r\n * @param start {?number=0}  开始位置\r\n * @param end {?number=target.length} 结束位置\r\n * @returns {string}\r\n * @lastUpdate 2.2.1\r\n */\r\nfunction hide(target, start = 0, end) {\r\n    if (type(target) !== 'String') {\r\n        target = toString$1(target);\r\n    }\r\n    if (start <= 0)\r\n        start = 0;\r\n    if (!end || (end > target.length)) {\r\n        end = target.length;\r\n        if (start === 0)\r\n            return target.replace(/./gi, '*');\r\n    }\r\n    const center_len = end - start;\r\n    const end_len = (target.length - end) || 0;\r\n    const reg = new RegExp(`(.{${start}})(.{${center_len}})(.{${end_len}})`, 'g');\r\n    const result = reg.exec(target);\r\n    if (result?.length === 4) {\r\n        result[2] = result[2].replace(/./gi, '*');\r\n        delete result[0];\r\n        return result.join('');\r\n    }\r\n    return target.replace(/./gi, '*');\r\n}\n\n/**\r\n * @title toDate\r\n * @description 字符串装换成Date对象\r\n * @param value string 可以转换成时间的字符串\r\n * @returns {Date}\r\n */\r\nfunction toDate(value) {\r\n    // ios 不支持 YYYY-MM-DD hh:mm:ss\r\n    if (/\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}/.test(value)) {\r\n        value.replaceAll('-', '/');\r\n    }\r\n    return new Date(value);\r\n}\n\n/**\r\n * @title deadline\r\n * @description 倒计时\r\n * @param target {Date} 目标时间\r\n * @param timeKey {?'year' | 'mouth' | 'day' | 'hour' | 'minute' | 'second' | 'timeStamp'}  指定倒计时单位\r\n * @param now {?Date = new Date()} 起始时间\r\n * @returns {number}\r\n */\r\nfunction deadline(target, timeKey = 'day', now = new Date()) {\r\n    const surplusTimeStamp = target.getTime() - now.getTime();\r\n    const surplusDay = Math.ceil(surplusTimeStamp / 86400000);\r\n    switch (timeKey) {\r\n        case 'year': return target.getFullYear() - now.getFullYear();\r\n        case 'mouth': return (target.getFullYear() - now.getFullYear()) * 12 + (target.getDate() - now.getDate());\r\n        case 'day': return surplusDay;\r\n        case 'hour': return surplusDay * 24;\r\n        case 'minute': return surplusDay * 1440;\r\n        case 'second': return surplusDay * 8640086400;\r\n        case 'timeStamp': return surplusDay;\r\n        default: return surplusTimeStamp;\r\n    }\r\n}\n\n/**\r\n * @title format\r\n * @description 时间格式化\r\n * @param time:number|string|Date  时间\r\n * @param pattern?:string 格式\r\n * @returns string 格式化后的数据\r\n\r\n * @note\r\n| 符号 | 结果| 描述 |\r\n|:----|:----|:----|\r\n| YYYY\t| 2022\t| 4位数字的年份(忽略大小写) |\r\n| YY\t|  1-14\t| 2 位数字的年份(忽略大小写) |\r\n| M  MM |\t1-12 |\t月份数字 |\r\n| D  DD |\t1-31 |\t日数(忽略大小写) |\r\n| H  HH\t| 0-23 |  24 小时制 |\r\n| h  hh\t| 1-12 |\t12 小时制 |\r\n| m  mm | 0-59 |\t分钟|\r\n| s  ss\t| 0-59 |\t秒钟|\r\n\r\n */\r\nfunction format(time = new Date(), pattern = 'YYYY-MM-DD') {\r\n    if (type(time) === 'Number') {\r\n        if (time.toString().length === 10)\r\n            time += '000';\r\n    }\r\n    const date = new Date(time);\r\n    const year = date.getFullYear();\r\n    // eslint-disable-next-line\r\n    if (isNaN(year)) {\r\n        return 'Invalid Date';\r\n    }\r\n    const month = date.getMonth() + 1;\r\n    const day = date.getDate();\r\n    const hour = date.getHours();\r\n    const minutes = date.getMinutes();\r\n    const seconds = date.getSeconds();\r\n    return replaces(pattern, [\r\n        { reg: /[Y|y]{4}/, value: spLength(year, 4, 4) },\r\n        { reg: /[Y|y]{2}/, value: spLength(year, 2, 2) },\r\n        { reg: /[M]{2}/, value: spLength(month, 2, 2) },\r\n        { reg: /[M]{1}/, value: spLength(month, 1, 2) },\r\n        { reg: /[D|d]{2}/, value: spLength(day, 2, 2) },\r\n        { reg: /[D|d]{1}/, value: spLength(day, 1, 2) },\r\n        { reg: /[H]{2}/, value: spLength(hour, 2, 2) },\r\n        { reg: /[H]{1}/, value: spLength(hour, 1, 2) },\r\n        { reg: /[h]{2}/, value: spLength(hour % 12, 2, 2) },\r\n        { reg: /[h]{1}/, value: spLength(hour % 12, 1, 2) },\r\n        { reg: /[m]{2}/, value: spLength(minutes, 2, 2) },\r\n        { reg: /[m]{1}/, value: spLength(minutes, 1, 2) },\r\n        { reg: /[s]{2}/, value: spLength(seconds, 2, 2) },\r\n        { reg: /[s]{1}/, value: spLength(seconds, 1, 2) }\r\n    ]);\r\n}\n\n/**\r\n * @title timezone\r\n * @description 指定时区时间偏移量, 转换为目标时间\r\n * @param originOffset {LikeNumber} 当前时间的时区(number:时间偏移量|string:时区)\r\n * @param targetOffset {LikeNumber} 目标时间的时区(number:时间偏移量|string:时区)\r\n * @returns {(data:Date)=>Date}\r\n * @note\r\n ```js\r\n const oDate = new Date('2022-12-11T07:58:07.945Z')\r\n const tDate = new Date('2022-12-11T15:58:07.945Z')\r\n timezone('1', 9 * 3600000)(oDate) ==> tDate\r\n ```\r\n */\r\nfunction timezone(originOffset, targetOffset) {\r\n    originOffset = isString(originOffset) ? toNumber(originOffset) * 3600000 : originOffset;\r\n    targetOffset = isString(targetOffset) ? toNumber(targetOffset) * 3600000 : targetOffset;\r\n    const offset = targetOffset - originOffset;\r\n    return (date) => new Date(date.getTime() + offset);\r\n}\n\n/**\r\n * @title isSameDate\r\n * @description 时间是否相同, 时间类型支持isDate的类型\r\n * @param timeA 比较时间\r\n * @param timeB 被比较时间\r\n * @returns {boolean}\r\n * @version 2.4.0\r\n */\r\nfunction isSameDate(timeA, timeB) {\r\n    if (!isTime(timeA) || !isTime(timeB))\r\n        return false;\r\n    if (timeA.toString() === timeB.toString())\r\n        return true;\r\n    if (new Date(timeA).getTime() === new Date(timeB).getTime())\r\n        return true;\r\n    return false;\r\n}\n\n/**\r\n * @title intervalDate\r\n * @description 两个日期间隔天数\r\n * @param startDate {Date}\r\n * @param endDate {Date}\r\n * @returns {number}\r\n * @version 2.4.0\r\n */\r\nconst intervalDate = (startDate, endDate) => Math.ceil(Math.abs(startDate.getTime() - endDate.getTime()) / 86400000);\n\n/**\r\n * @title dayOfYear\r\n * @description 指定日期位于今年的第几天\r\n * @param date {Date}\r\n * @returns {number}\r\n */\r\nconst dayOfYear = (date) => Math.floor((date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 1000 / 60 / 60 / 24);\n\n/**\r\n * @title logGroup\r\n * @description 分组打印(简化console.groupCollapsed)\r\n * @param { string } name 分组名称\r\n * @param { unknown[] } ...args 需要分组打印的结果\r\n * @example logGroup(name[, ...args])\r\n * @return boolean\r\n */\r\nfunction logGroup(name = '', ...args) {\r\n    try {\r\n        console.groupCollapsed(`--- ${name} ---`);\r\n        args.forEach((item) => {\r\n            console.log(item);\r\n        });\r\n        console.groupEnd();\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        console.error(error);\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * @title logAsync\r\n * @description 可直接打印 Promise 值\r\n * @param ...args\r\n * @returns boolean\r\n * @version 2.2.0\r\n */\r\nasync function logAsync(...args) {\r\n    try {\r\n        const result = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            result.push(await args[i]);\r\n        }\r\n        console.log(...result);\r\n        return true;\r\n    }\r\n    catch (error) {\r\n        console.error(error);\r\n        return false;\r\n    }\r\n}\n\nfunction matchNumberValue(val, valer) {\r\n    const valType = type(val);\r\n    const valerType = type(valer);\r\n    if (valerType === 'RegExp') {\r\n        return valer.test(String(val));\r\n    }\r\n    if (valType !== 'Number') {\r\n        return false;\r\n    }\r\n    if (valerType === 'String') {\r\n        const [matNum, Sym = '='] = /(?<=([<>=!]+))[0-9]+/gi.exec(valer) || [];\r\n        switch (Sym) {\r\n            case '=': return val === Number(matNum);\r\n            case '>': return val > Number(matNum);\r\n            case '>=': return val >= Number(matNum);\r\n            case '<': return val < Number(matNum);\r\n            case '<=': return val <= Number(matNum);\r\n            case '<>':\r\n            case '!=': return val != Number(matNum);\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @title toPathValue\r\n * @description 通过path 来获取值\r\n * @param val 待取值\r\n * @param path string 路径 (若路径有`.` 可用`\\\\.`代替)\r\n * @returns 通过路径获取对应值\r\n */\r\nfunction toPathValue(val, path) {\r\n    const paths = path.split('.') || [];\r\n    let beforeKey = '';\r\n    paths.forEach((item) => {\r\n        if (beforeKey !== '' && val[beforeKey + item] !== undefined) {\r\n            val = val[beforeKey + item] || undefined;\r\n            return;\r\n        }\r\n        if (val[item]) {\r\n            val = val[item] || undefined;\r\n        }\r\n        else if (/\\\\$/.test(item)) {\r\n            beforeKey += item.replace(/\\\\$/, '.');\r\n        }\r\n    });\r\n    return val;\r\n}\n\n/**\r\n * @title matchValue\r\n * @param val 被比较值\r\n * @param valer 比较值 / 可为正则\r\n * @param path 值的路径 用逗号隔开\r\n * @returns boolean\r\n */\r\nfunction matchValue(val, valer, path) {\r\n    if (path) {\r\n        val = toPathValue(val, path);\r\n    }\r\n    if (equal(val, valer)) {\r\n        return true;\r\n    }\r\n    if (type(valer) === 'RegExp') {\r\n        return valer.test(String(val));\r\n    }\r\n    if (type(val) === 'Number') {\r\n        return matchNumberValue(val, valer);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @title equal\r\n * @description 比较是否值和类型是否相等\r\n * @param value any\r\n * @param lastValue any\r\n * @returns\r\n */\r\nfunction equal(value, lastValue) {\r\n    if (value === lastValue)\r\n        return true;\r\n    if (type(value) !== type(value))\r\n        return false;\r\n    if (type(value) === 'Symbol')\r\n        return false;\r\n    if (stringify(value) === stringify(lastValue))\r\n        return true;\r\n    return false;\r\n}\n\nfunction deepClonePredicate(value) {\r\n    switch (type(value)) {\r\n        case 'RegExp':\r\n        case 'Function':\r\n        case 'AsyncFunction':\r\n        case 'GeneratorFunction':\r\n        case 'Array':\r\n        case 'Object': {\r\n            const cloneObj = new value.constructor();\r\n            for (const key in value) {\r\n                if (value.hasOwnProperty(key)) {\r\n                    cloneObj[key] = deepClonePredicate(value[key]); // 递归拷贝  \r\n                }\r\n            }\r\n            return cloneObj;\r\n        }\r\n        case 'Date': {\r\n            return new Date(value);\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * @title deepClone\r\n * @description 深拷贝\r\n * @param value {any}\r\n * @returns {any}\r\n * @version 2.4.1\r\n */\r\nfunction deepClone(value) {\r\n    return deepClonePredicate(value);\r\n}\n\n/**\r\n * @title throwError<<Params extends any[], R = any>\r\n * @param func: (...args: Params) => R 待捕获错误的函数\r\n * @param isErrorResult : R\r\n * @returns (...args:Params)=>R\r\n */\r\nfunction throwError(func, isErrorResult) {\r\n    return function (...args) {\r\n        try {\r\n            return func(...args);\r\n        }\r\n        catch (error) {\r\n            return isErrorResult;\r\n        }\r\n    };\r\n}\r\n/**\r\n * @title asyncThrowError<<Params extends any[], R = any>\r\n * @description 异步处理\r\n * @param func: (...args: Params) => R 待捕获错误的函数\r\n * @param isErrorResult : R\r\n * @returns (...args:Params)=>R\r\n */\r\nfunction asyncThrowError(func, isErrorResult) {\r\n    return async function (...args) {\r\n        try {\r\n            return await func(...args);\r\n        }\r\n        catch (error) {\r\n            return isErrorResult;\r\n        }\r\n    };\r\n}\n\n/**\r\n * @title ban<Params extends [], Return>\r\n * @description 限制 方法的超时和执行次数\r\n * @param func Func<Params, Return>\r\n * @param config BanConfig\r\n * @returns function (...args: Params): Return\r\n */\r\nfunction ban(func, config) {\r\n    let { timeout = 3000, count = 1000000 } = config;\r\n    if (timeout < 1)\r\n        timeout = 3000;\r\n    if (count < 1)\r\n        count = 1000000;\r\n    let runCount = 1;\r\n    return function (...args) {\r\n        if (runCount > count)\r\n            throw new Error('Possible infinite loop');\r\n        const startTime = Date.now();\r\n        const result = func(...args);\r\n        if (Date.now() - startTime > timeout) {\r\n            throw new Error('Time out');\r\n        }\r\n        runCount++;\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * @title asyncBan<Params extends [], Return>\r\n * @param func AsyncFunc<Params, Return>\r\n * @param config BanConfig\r\n * @returns function (...args: Params): Return\r\n */\r\nfunction asyncBan(func, config) {\r\n    let { timeout = 3000, count = 1000000 } = config;\r\n    if (timeout < 1)\r\n        timeout = 3000;\r\n    if (count < 1)\r\n        count = 1000000;\r\n    let runCount = 1;\r\n    return async function (...args) {\r\n        if (runCount > count)\r\n            throw new Error('Possible infinite loop');\r\n        const startTime = Date.now();\r\n        const result = await func(...args);\r\n        if (Date.now() - startTime > timeout) {\r\n            throw new Error('Time out');\r\n        }\r\n        runCount++;\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * @title catchError<Params extends [], Return>\r\n * @param func Func<Params, Return>\r\n * @param errorReturnValue Return\r\n * @returns function (...args: Params): Return\r\n */\r\nfunction catchError(func, errorReturnValue) {\r\n    return function (...args) {\r\n        try {\r\n            return func(...args);\r\n        }\r\n        catch (error) {\r\n            return errorReturnValue;\r\n        }\r\n    };\r\n}\n\n/**\r\n * @title changeCase\r\n * @description  字符转换\r\n * --- type: FirstUpper:首字母大写 FirstLower：首字母小写  Upper：全部大写 Lower：全部小写\r\n * @param str string\r\n * @param type number\r\n * @returns string\r\n */\r\nfunction changeCase(str, type = 'Upper') {\r\n    switch (type) {\r\n        case 'FirstUpper':\r\n            return str.replace(/\\b.*/g, (word) => word.substring(0, 1).toUpperCase() + word.substring(1));\r\n        case 'FirstLower':\r\n            return str.replace(/\\b.*/g, (word) => word.substring(0, 1).toLowerCase() + word.substring(1));\r\n        case 'Upper':\r\n            return str.toUpperCase();\r\n        case 'Lower':\r\n            return str.toLowerCase();\r\n        default:\r\n            return str;\r\n    }\r\n}\n\nfunction isEqual(compareValue, beCompareValue) {\r\n    if (compareValue === beCompareValue)\r\n        return true;\r\n    return stringify(compareValue) === stringify(beCompareValue);\r\n}\n\n/**\r\n * @title filter<T extends object>\r\n * @description 单层过滤\r\n * @param list {T[]} 待过滤数组\r\n * @param filterCondition {FilterCondition<T>} 过滤条件\r\n * @param retainNotObject {boolean=false} 是否保留非对象项\r\n * @returns {T[]}\r\n * @version 2.3.1\r\n */\r\nfunction filter(list, filterCondition, retainNotObject = false) {\r\n    if (type(list) !== 'Array')\r\n        return [];\r\n    if (!filterCondition || !list || list.length === 0)\r\n        return list;\r\n    if (type(filterCondition) === 'Function') {\r\n        return list.filter(filterCondition);\r\n    }\r\n    return list.filter((item) => {\r\n        if (!isObject(item))\r\n            return retainNotObject;\r\n        let flag = true;\r\n        if (type(filterCondition) === 'Object') {\r\n            for (const key in filterCondition) {\r\n                const unit = filterCondition[key];\r\n                const val = item[key];\r\n                if (val !== unit && type(unit) !== 'RegExp') {\r\n                    flag = false;\r\n                    break;\r\n                }\r\n                if (type(unit) === 'RegExp' && !unit.test(val)) {\r\n                    flag = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return flag;\r\n    });\r\n}\n\n/**\r\n * @title selects<T>\r\n * @description 指定范围 来随机选择数组元素\r\n * @param list: T[]\r\n * @param min: number\r\n * @param max: number (包括)\r\n * @returns T[]\r\n */\r\nfunction selects(list, min, max) {\r\n    if (max > list.length) {\r\n        max = list.length - 1;\r\n    }\r\n    let len = random(min, max) || 0;\r\n    const result = [];\r\n    let index = 0;\r\n    while (len--) {\r\n        index = ~~(Math.random() * list.length);\r\n        result.push(list[index]);\r\n        list.splice(index, 1);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @title select<T>\r\n * @description 选择数组其中一项, 不指定就随机选一\r\n * @param list T[] 待选择数组\r\n * @param index ?number 指定选择索引(可为负数)\r\n * @returns T|null 选择项\r\n */\r\nfunction select(list = [], index) {\r\n    const len = list.length;\r\n    if (len === 0)\r\n        return null;\r\n    if (!index && index !== 0)\r\n        return list[~~(Math.random() * list.length)];\r\n    if (index > len)\r\n        return list[index % len];\r\n    if (index > -1)\r\n        return list[index];\r\n    if (index < 0)\r\n        return list[list.length + (index % len)];\r\n    return null;\r\n}\n\n/**\r\n * @title toArray<T>\r\n * @description 将非数组转换为数组\r\n * @param value T | T[]\r\n * @returns T[]\r\n */\r\nfunction toArray(value) {\r\n    if (Array.isArray(value))\r\n        return value;\r\n    if ([undefined, null, NaN].includes(value))\r\n        return [];\r\n    return [value];\r\n}\n\n/**\r\n * @title pick\r\n * @description 从数组中取任意 一个 元素\r\n * @param any[] list\r\n * @returns 数组中任意一个\r\n */\r\nfunction pick(list) {\r\n    return list[Math.floor(Math.random() * list.length)];\r\n}\r\n/**\r\n * @title unique<T>\r\n * @description 去除数组重复项\r\n * @param T[] list 待过滤数组\r\n * @returns T[]\r\n */\r\nfunction unique(list) {\r\n    return [...new Set(list)];\r\n}\r\n/**\r\n * @title chunk<T>\r\n * @description 通过 size 切割数组\r\n * @param list T[]\r\n * @param size number 切割点索引\r\n * @returns T[][] [ [切割点前数据], [切割点后数据] ]\r\n */\r\nfunction chunk(list, size) {\r\n    return [list.slice(0, size), list.slice(size)];\r\n}\r\n/**\r\n * @title concat<T>\r\n * @description 连接多个数组\r\n * @params ...list any[][] 多个数组\r\n * @returns any[]\r\n */\r\nfunction concat(...list) {\r\n    let result = [];\r\n    if (list && list.length > 0) {\r\n        const len = list.length;\r\n        let i = 0;\r\n        while (i < len) {\r\n            if (Array.isArray(list[i])) {\r\n                result = result.concat(list[i]);\r\n            }\r\n            else {\r\n                result.push(list[i]);\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @title drop<T>\r\n * @description 去除前n个元素\r\n * @param T[] list 数组\r\n * @param number n=0 要去除元素个数\r\n * @returns T[] list 剩余切片\r\n */\r\nfunction drop(list = [], n = 0) {\r\n    while (n--) {\r\n        if (list.length < 1)\r\n            return [];\r\n        list.shift();\r\n    }\r\n    return list;\r\n}\r\n/**\r\n * @title dropRight<T>\r\n * @description 从右往左删除的指定个数\r\n * @param list T[] 要处理的数组\r\n * @param n=1 需要删除的元素数量\r\n * @returns T[]\r\n */\r\nfunction dropRight(list, n = 1) {\r\n    const len = list.length || 0;\r\n    return list.splice(0, len - n);\r\n}\r\n/**\r\n * @title fill<T>\r\n * @description 在原有数组上改变, 修改指定位置的值\r\n * @param array T[] 待填充改变的数组\r\n * @param value T 填充值\r\n * @param num 填充个数\r\n * @returns\r\n */\r\nfunction fill(array, value, num = 0) {\r\n    while (num--)\r\n        array.push(value);\r\n    return array;\r\n}\r\n/**\r\n * @title difference<T>\r\n * @description 过滤数组\r\n * @param list T[] 待过滤的数组\r\n * @param ...filterConditions:T[] 过滤使用的条件\r\n * @returns T[] 过滤后的数组(new)\r\n */\r\nfunction difference(list, ...filterConditions) {\r\n    if (!list)\r\n        return [];\r\n    const result = list || [];\r\n    // 整合过滤条件\r\n    if (!filterConditions)\r\n        return list;\r\n    return result.filter((item) => {\r\n        return !filterConditions.includes(item);\r\n    });\r\n}\n\n/**\r\n * @title loop<T>\r\n * @description: 指定次数遍历\r\n * @param num  {number}\r\n * @param  callback  {?(indexes: number[]) => T}\r\n * @returns {T[]}\r\n * @version: 2.3.2\r\n */\r\nfunction loop(num, callback = ((indexes) => indexes), indexes = []) {\r\n    const result = [];\r\n    for (let i = 0; i < num; i++) {\r\n        result.push(callback(indexes.concat(i)));\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @title loops<T>\r\n * @description: 指定次数遍历\r\n * @param length  {number[]}\r\n * @param callback  {((indexes: number[]) => T) = ((indexes: number[]) => indexes as T)}\r\n * @returns {Array}\r\n * @version: 2.3.2\r\n */\r\nfunction loops(num, callback = ((indexes) => indexes), indexes = []) {\r\n    const len = num.length;\r\n    if (len === 0) {\r\n        return [];\r\n    }\r\n    if (len === 1) {\r\n        return loop(num[0], callback, indexes);\r\n    }\r\n    const [_len, ..._length] = num;\r\n    const result = [];\r\n    for (let i = 0; i < _len; i++) {\r\n        result.push(loops(_length, callback, indexes.concat(i)));\r\n    }\r\n    return result;\r\n}\r\nfunction loopGroup(num, callback = ((indexes) => indexes), indexes = []) {\r\n    const result = [];\r\n    loops(num, (_indexes) => {\r\n        result.push(callback(_indexes));\r\n        return _indexes;\r\n    }, indexes);\r\n    return result;\r\n}\r\n/**\r\n * @title loopArray<T>\r\n * @description: 数组遍历\r\n * @param arrays {T[]}\r\n * @param callback {(unit:T,index?:number)=>true|void}\r\n * @returns {T|undefined}\r\n * @version: 2.3.2\r\n */\r\nfunction loopArray(array, callback) {\r\n    for (let i = 0; i < length; i++) {\r\n        if (callback(array[i], i)) {\r\n            return array[i];\r\n        }\r\n    }\r\n    return;\r\n}\r\n/**\r\n * @title loopArray<T>\r\n * @description: 数组遍历\r\n * @version: 2.1.11\r\n * @param arrays {T[]}\r\n * @param callback {(unit:T,index?:number)=>true|void}\r\n * @returns number\r\n * @version: 2.3.2\r\n */\r\nfunction loopArrays(arrays, callback) {\r\n    const result = [];\r\n    loops(arrays.map(item => item.length), (indexes) => {\r\n        result.push(callback(indexes.map((i, j) => arrays[j][i]), indexes));\r\n        return indexes;\r\n    });\r\n    return result;\r\n}\n\n/**\r\n * @title zip\r\n * @description: 创建一个分组元素的数组，数组的第一个元素包含所有给定数组的第一个元素，数组的第二个元素包含所有给定数组的第二个元素，以此类推\r\n * @param arrays  {...any[]}\r\n * @returns {any[]}\r\n * @version: 2.1.11\r\n */\r\nfunction zip(...arrays) {\r\n    const len = arrays.length;\r\n    const maxLen = arrays[0].length;\r\n    const result = loops([maxLen, len], (indexes) => {\r\n        if (indexes.length !== maxLen)\r\n            return;\r\n        const [depth0, depth1] = indexes;\r\n        return arrays[depth1][depth0];\r\n    });\r\n    return result;\r\n}\r\nfunction zipObject(props, values) {\r\n    const record = {};\r\n    for (let i = 0; i < props.length; i++) {\r\n        record[toString$1(props[i])] = values[i];\r\n    }\r\n    return record;\r\n}\r\n// const _path = (path: string, value: any) => {\r\n// \tconst _record = {}\r\n// \t// return _path(path, value)\r\n// }\r\n// export function zipObjectDeep<T>(props: string[], values: any[]): T {\r\n// \tconst record: T = {} as T\r\n// \tconst _props = [...props]\r\n// \tfor (let i = 0; i < props.length; i++) {\r\n// \t\t// const keys = props[i].split('.')\r\n// \t\tconst key = /(\\w)\\./.exec(props[i])\r\n// \t\t// if (key?.length === 2) {\r\n// \t\t// \trecord[key] =\r\n// \t\t// }\r\n// \t\t// record[keys[0]] = _path(,values[i])\r\n// \t\t// for (let j = 1; i < keys.length; j++) {\r\n// \t\t// }\r\n// \t\t// record[props[i]] = values[i]\r\n// \t}\r\n// \treturn record\r\n// }\n\n/**\r\n * @title flat\r\n * @description 数组扁平化\r\n * @param list <Array>\r\n * @param depth <?number=1> 深度\r\n * @returns <Array>\r\n * @version: 2.2.0\r\n */\r\nfunction flat(list, depth = 1) {\r\n    if (!Array.isArray(list))\r\n        return toArray(list);\r\n    if (list.length === 0 || depth < 1)\r\n        return [];\r\n    if (depth === 1)\r\n        return list.flatMap(i => i);\r\n    return list.flat(depth);\r\n}\n\n/**\r\n * @title existKeys\r\n * @description 判断对象是否拥有指定keys\r\n * @param obj object\r\n * @param keys string[] | string\r\n * @returns boolean\r\n */\r\nfunction existKeys(obj, keys) {\r\n    const objKeys = Object.keys(obj);\r\n    keys = toArray(keys);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        if (objKeys.includes(keys[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @title omitRecord<T extends Record<string, any> = Record<string, any>>\r\n * @description 忽略object属性\r\n * @param record T\r\n * @param propertys string[]\r\n * @returns T\r\n */\r\nfunction omitRecord(record, propertys = []) {\r\n    propertys.forEach(property => {\r\n        record[property] && delete record[property];\r\n    });\r\n    return record;\r\n}\n\n/**\r\n * @title serialize\r\n * @description 序列化对象\r\n * @param query object\r\n * @param encode boolean = false\r\n * @returns string\r\n */\r\nfunction serialize(query, encode = false) {\r\n    return Object.keys(query)\r\n        .map((key) => `${key}=${encode ? encodeURIComponent(query[key]) : query[key]}`)\r\n        .join('&');\r\n}\n\nfunction includes(list, item) {\r\n    if (isObject(item)) {\r\n        for (let i = 0; i < list.length; i++)\r\n            if (isEqual(list[i], item))\r\n                return true;\r\n    }\r\n    if (list.includes(item))\r\n        return true;\r\n    return false;\r\n}\r\nclass MapEntity {\r\n    map;\r\n    weakMap;\r\n    keyList = [];\r\n    size = 0;\r\n    constructor() {\r\n        this.map = new Map();\r\n        this.weakMap = new WeakMap();\r\n        this.size = 0;\r\n    }\r\n    clear() {\r\n        this.map.clear();\r\n        this.weakMap = new WeakMap();\r\n        this.keyList = [];\r\n        this.size = 0;\r\n    }\r\n    delete(key) {\r\n        if (!includes(this.keyList, key))\r\n            return false;\r\n        --this.size;\r\n        const newKeyList = [...this.keyList];\r\n        this.keyList = this.keyList.filter(item => !isEqual(item, key));\r\n        if (!isObject(key))\r\n            return this.map.delete(key);\r\n        for (let i = 0; i < newKeyList.length; i++)\r\n            if (isEqual(newKeyList[i], key))\r\n                return this.weakMap.delete(newKeyList[i]);\r\n        return false;\r\n    }\r\n    forEach(callback, thisArg = {}) {\r\n        const newCallback = callback.bind(thisArg);\r\n        for (let i = 0; i < this.keyList.length; i++) {\r\n            const key = this.keyList[i];\r\n            let val;\r\n            if (isObject(key)) {\r\n                val = this.weakMap.get(key);\r\n            }\r\n            else {\r\n                val = this.map.get(key);\r\n            }\r\n            newCallback(val, key, this);\r\n        }\r\n    }\r\n    get(key) {\r\n        if (!isObject(key))\r\n            return this.map.get(key);\r\n        for (let i = 0; i < this.keyList.length; i++)\r\n            if (isEqual(this.keyList[i], key))\r\n                return this.weakMap.get(this.keyList[i]);\r\n        return undefined;\r\n    }\r\n    has(key) {\r\n        if (isObject(key))\r\n            return this.weakMap.has(key);\r\n        return this.map.has(key);\r\n    }\r\n    set(key, value) {\r\n        if (includes(this.keyList, key)) {\r\n            if (!isObject(key)) {\r\n                this.map.set(key, value);\r\n                return this;\r\n            }\r\n            for (let i = 0; i < this.keyList.length; i++)\r\n                if (isEqual(this.keyList[i], key))\r\n                    this.weakMap.set(this.keyList[i], value);\r\n            return this;\r\n        }\r\n        this.keyList.push(key);\r\n        ++this.size;\r\n        if (!isObject(key)) {\r\n            this.map.set(key, value);\r\n            return this;\r\n        }\r\n        for (let i = 0; i < this.keyList.length; i++)\r\n            if (isEqual(this.keyList[i], key))\r\n                this.weakMap.set(this.keyList[i], value);\r\n        this.weakMap.set(key, value);\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @title runFunc\r\n * @description 运行函数, 支持普通函数和async函数, 否则返回func\r\n * @param func\r\n * @param ...args\r\n * @returns\r\n */\r\nfunction runFunc(func, ...args) {\r\n    if (type(func) === 'Function') {\r\n        return func(...args);\r\n    }\r\n    if (type(func) === 'AsyncFunction') {\r\n        return (async () => await func(...args))();\r\n    }\r\n    return func;\r\n}\n\n/**\r\n * @title toPromise<T>\r\n * @description 将方法或值转换为Promise对象, 若传输values切target为function, 就会返回执行结果\r\n * @param target any\r\n * @param ...values ?any[]\r\n * @returns Promise<T>\r\n */\r\nfunction toPromise(target, ...values) {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (type(target) === 'Function' && values) {\r\n                resolve(target(...values));\r\n            }\r\n            else {\r\n                resolve(target);\r\n            }\r\n        }\r\n        catch (err) {\r\n            reject(err);\r\n        }\r\n    });\r\n}\r\n/**\r\n * @title once\r\n * @description  fn 方法只会执行一次\r\n * @param fn 指定值运行一次的方法\r\n * @returns 返回封装后的方法\r\n */\r\nfunction once(fn) {\r\n    let returnValue;\r\n    let canRun = true;\r\n    return function () {\r\n        if (canRun) {\r\n            returnValue = fn.apply(this, arguments);\r\n            canRun = false;\r\n        }\r\n        return returnValue;\r\n    };\r\n}\r\n/**\r\n * @title throttle\r\n * @description 节流: 用于限制函数触发频率, 每个delay时间间隔，最多只能执行函数一次\r\n * @param fn function 待处理函数\r\n * @param interval number 间隔\r\n * @returns func\r\n */\r\nfunction throttle(fn, interval) {\r\n    let lastTime = 0;\r\n    return function throttled(...args) {\r\n        const timeSinceLastExecution = Date.now() - lastTime;\r\n        if (!lastTime || timeSinceLastExecution >= interval) {\r\n            fn.apply(this, ...args);\r\n            lastTime = Date.now();\r\n        }\r\n    };\r\n}\r\n/**\r\n * @title debounce\r\n * @description\r\n * -- 防抖:  时间内只会执行一次 可以减少函数触发的频率\r\n * -- 当函数触发时，使用一个定时器延迟执行操作。\r\n * -- 当函数被再次触发时，清除已设置的定时器，重新设置定时器。\r\n * -- 如果上一次的延迟操作还未执行，则会被清除。\r\n * @param fn function\r\n * @param interval number\r\n * @returns\r\n */\r\nfunction debounce(fn, interval) {\r\n    const timer = 0;\r\n    const debounced = () => {\r\n        clearTimeout(timer);\r\n        const args = arguments;\r\n        setTimeout(() => {\r\n            fn.apply(this, args);\r\n        }, interval);\r\n    };\r\n    return debounced;\r\n}\r\n/**\r\n * @title after\r\n * @description 调用n次后才触发func\r\n * @param n 调用后多少次才执行\r\n * @param func 限定的函数\r\n * @returns 新的限定函数\r\n */\r\nfunction after(n = 0, func) {\r\n    return function (...args) {\r\n        if (--n < 0)\r\n            return func(...args);\r\n        return;\r\n    };\r\n}\r\n/**\r\n * @title ary\r\n * @description 调用func最多接受n个参数\r\n * @param func 限定函数\r\n * @param n 限制参数数量\r\n * @returns 新的覆盖函数\r\n */\r\nfunction ary(func, n) {\r\n    return function (...args) {\r\n        return func(...args.splice(0, n));\r\n    };\r\n}\r\n/**\r\n * @title before\r\n * @description 调用n次后，再调用就会返回最后一次调用的结果\r\n * @param n 超过n次不再调用\r\n * @param func 限定函数\r\n * @returns 新的限定函数\r\n */\r\nfunction before(n, func) {\r\n    let lastResult = undefined;\r\n    return function (...args) {\r\n        if (n-- > 0) {\r\n            lastResult = func(...args);\r\n        }\r\n        return lastResult;\r\n    };\r\n}\r\n/**\r\n * @title bind\r\n * @description thisArg绑定func的this，并且func会接收partials附加参数\r\n * @param func 绑定的函数\r\n * @param thisArg 绑定的对象\r\n * @param partials 附加的部分参数\r\n * @returns 新的绑定函数\r\n */\r\nfunction bind(func, thisArg = {}, ...partials) {\r\n    return function (...args) {\r\n        if (func)\r\n            return func.call(thisArg, ...[...partials, ...args]);\r\n        return;\r\n    };\r\n}\r\n/**\r\n * @title curry\r\n * @description 柯里化\r\n * @param func 待柯里化函数\r\n * @param len 待柯里化参数个数\r\n * @returns 柯里化函数\r\n */\r\nfunction curry(func, len) {\r\n    // 第一次执行时，定义一个数组专门用来存储所有的参数\r\n    let _args = [];\r\n    const _resFn = function (...args) {\r\n        _args = _args.concat(args);\r\n        if (_args.length < len) {\r\n            return _resFn;\r\n        }\r\n        return func(..._args);\r\n    };\r\n    return _resFn;\r\n}\r\n/**\r\n * @title delay\r\n * @param func 指定函数\r\n * @param delayTime 延迟时间\r\n * @param args 传输参数\r\n * @returns func执行结果(Promise)\r\n */\r\nfunction delay(func, delayTime = 0, ...args) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve(func(...args));\r\n        }, delayTime);\r\n    });\r\n}\r\n/**\r\n * @title flip\r\n * @param func 要翻转参数的函数\r\n * @param args 反转参数\r\n * @returns\r\n */\r\nfunction flip(func) {\r\n    return function (...args) {\r\n        return func(...args.reverse());\r\n    };\r\n}\n\nfunction useValue(itteratee) {\r\n    const __type = type(itteratee);\r\n    return function (val) {\r\n        if (__type === 'String')\r\n            return val[itteratee];\r\n        if (__type === 'Function')\r\n            return itteratee(val);\r\n        return val;\r\n    };\r\n}\n\n/**\r\n * @title isEven\r\n * @description 偶数\r\n * @param num {number}\r\n * @returns {boolean}\r\n */\r\nconst isEven = num => num % 2 === 0;\r\n/**\r\n * @title isOdd\r\n * @description 奇数\r\n * @param num {number}\r\n * @returns {boolean}\r\n */\r\nconst isOdd = num => num % 2 === 1;\n\n/**\r\n * @title average\r\n * @description 平均数\r\n * @param ...args {number[]}\r\n * @returns {number}\r\n */\r\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\n/**\r\n * @ 无限大（小）当做 js Number 的最大（小）值[主要处理计算异常的问题, 二期再加入大位数处理]\r\n * @ 二期再加入大位数计算\r\n */\r\nconst __binary = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', 'B'];\r\n/**\r\n * @title HEX\r\n * @description 将数字装换成需要装换的数据格式(k, m, g, t, p, e, z, y, b)\r\n * @param num (number|string) 待转换的数子 (<binary^ 9)\r\n * @param binary (number) 进制 (default:1024)\r\n * @returns (number)\r\n */\r\nfunction toHEX(num, binary = 1024) {\r\n    let result = '';\r\n    let tempNum = Number(num);\r\n    if (num > binary ** 9)\r\n        return '1024B';\r\n    const index = 0;\r\n    function translate(index) {\r\n        const _index_num = tempNum % binary;\r\n        tempNum = (tempNum - _index_num) / binary;\r\n        if (_index_num > 0)\r\n            result = _index_num + __binary[index] + result;\r\n        if (tempNum < 1)\r\n            return;\r\n        translate(++index);\r\n    }\r\n    translate(index);\r\n    return result;\r\n}\r\n/**\r\n * @title add\r\n * @description 两数求和\r\n * @param augend number 加数\r\n * @param addend number 被加数\r\n * @returns number ( 不会超过数字的边界值 1.7976931348623157e+308 )\r\n */\r\nfunction add(augend, addend) {\r\n    return toNumber(toNumber(augend) + toNumber(addend));\r\n}\r\n/**\r\n * @title ceil\r\n * @description 向上取整的值(没有对number边界值[Infinity值处理])\r\n * @param num 要向上舍入的值\r\n * @param precision number = 0 精度(负数就是想整数部分取整)\r\n * @returns number\r\n */\r\nfunction ceil(num, precision = 0) {\r\n    return Math.ceil(num * toNumber(10 ** precision)) * toNumber(10 ** -precision);\r\n}\r\n/**\r\n * @title divide\r\n * @description 相除\r\n * @param dividend number 除数\r\n * @param divisor number 被除数\r\n * @returns number 商\r\n */\r\nfunction divide(dividend, divisor) {\r\n    if (divisor >= MAX_VALUES_NUMBER || divisor <= MIN_VALUES_NUMBER)\r\n        return 0;\r\n    return toNumber(dividend) / toNumber(divisor);\r\n}\r\n/**\r\n * @title floor\r\n * @description 向下取整(没有对number边界值[Infinity值处理])\r\n * @param num 待向下舍入的值\r\n * @param precision 精度 (负数就是处理整数部分)\r\n * @returns 向下取整\r\n */\r\nfunction floor(num, precision = 0) {\r\n    return (Math.floor(num * toNumber(10 ** precision)) * toNumber(10 ** -precision));\r\n}\r\n/**\r\n * @title max\r\n * @description 求最大值(只会判断有效值), 只会统计number | string类型的数值\r\n * @param list 数组\r\n * @returns 最大值\r\n */\r\nfunction max(list) {\r\n    let maxValue = undefined;\r\n    list.forEach((val) => {\r\n        const item = Number(val);\r\n        if (isEffectNumber(item)) {\r\n            if (maxValue === undefined) {\r\n                maxValue = item;\r\n            }\r\n            else\r\n                maxValue = item < maxValue ? maxValue : item;\r\n        }\r\n    });\r\n    return maxValue;\r\n}\r\n/**\r\n * @title maxBy\r\n * @description 求最大值\r\n * @param list 要迭代数组\r\n * @param itteratee 迭代函数 / key\r\n * @returns 最大值\r\n */\r\nfunction maxBy(list, itteratee) {\r\n    const _type = type(itteratee);\r\n    if (_type === 'Undefined') {\r\n        return max(list);\r\n    }\r\n    let maxValue = undefined;\r\n    let result = undefined;\r\n    const handleValue = useValue(itteratee);\r\n    list.forEach((val) => {\r\n        const item = Number(handleValue(val));\r\n        if (isEffectNumber(item)) {\r\n            if (maxValue === undefined) {\r\n                maxValue = item;\r\n                result = val;\r\n            }\r\n            if (item > maxValue) {\r\n                maxValue = item;\r\n                result = val;\r\n            }\r\n        }\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * @title mean\r\n * @description 求平均值\r\n * @param list 要迭代的数组\r\n * @returns 平均值\r\n */\r\nfunction mean(list) {\r\n    return sum(list) / list.length;\r\n}\r\n/**\r\n * @title meanBy\r\n * @description 求平均数\r\n * @param list 要迭代的数组\r\n * @param itteratee 迭代函数 / key\r\n * @returns 平均数\r\n */\r\nfunction meanBy(list, itteratee) {\r\n    return list.reduce((total = 0, item) => {\r\n        const itemNum = Number(useValue(itteratee)(item));\r\n        if (isNumber(itemNum)) {\r\n            return total + itemNum;\r\n        }\r\n        if (isNumber(total)) {\r\n            return total;\r\n        }\r\n        return 0;\r\n    }) / list.length;\r\n}\r\n/**\r\n * @title min\r\n * @description 求最小值\r\n * @param list 要迭代的数组\r\n * @returns 最小值\r\n */\r\nfunction min(list) {\r\n    return minBy(list);\r\n}\r\n/**\r\n * @title minBy\r\n * @description 求最小值\r\n * @param list 要迭代的数组\r\n * @param itteratee 迭代函数 / key\r\n * @returns 最小值\r\n */\r\nfunction minBy(list, itteratee) {\r\n    if (list.length === 0)\r\n        return undefined;\r\n    let result = undefined;\r\n    let len = list.length;\r\n    while (len--) {\r\n        const val = Number(useValue(itteratee)(list[len]));\r\n        if (isEffectNumber(val)) {\r\n            result = list[len];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @title sum\r\n * @description 求和\r\n * @param list 要迭代的数组\r\n * @returns 总和\r\n * @version 2.2.3\r\n */\r\nfunction sum(list = []) {\r\n    return list.reduce((total = 0, item) => {\r\n        const itemNum = Number(item);\r\n        if (isNumber(itemNum)) {\r\n            return total + itemNum;\r\n        }\r\n        if (isNumber(total)) {\r\n            return total;\r\n        }\r\n        return 0;\r\n    });\r\n}\r\n/**\r\n * @title sumBy\r\n * @description 求和\r\n * @param list 要迭代的数组\r\n * @param itteratee 迭代函数 / key\r\n * @returns 总和\r\n */\r\nfunction sumBy(list, itteratee) {\r\n    if (list.length === 0)\r\n        return undefined;\r\n    let total = 0;\r\n    let len = list.length;\r\n    while (len--) {\r\n        const val = Number(useValue(itteratee)(list[len]));\r\n        if (isEffectNumber(val)) {\r\n            if (total === undefined)\r\n                total = 0;\r\n            total += val;\r\n        }\r\n    }\r\n    return total;\r\n}\r\n/**\r\n * @title multiply\r\n * @description 相乘\r\n * @param augend number 乘数\r\n * @param addend number 被乘数\r\n * @returns 积\r\n */\r\nfunction multiply(augend, addend) {\r\n    return toNumber(toNumber(augend) * toNumber(addend));\r\n}\n\n/**\r\n * @title EventEmitter<T, U>\r\n * @description 简易观察者模式\r\n * @property $cache {Record<string,T[]>} 事件缓存\r\n * @property $on {(name:string,fn:T)=>void} 绑定事件\r\n * @property $off {(name: string)=>boolean} 移除事件的名称\r\n * @property $once {<Params extends any[] = any[]>(name: string, ...args: Params)=>U[]} 触发后就移除当前事件\r\n * @property $emit {<Params extends any[] = any[]>(name: string, ...args: Params)=> U[]} 触发事件\r\n * @note\r\n ```js\r\n const ev = new EventEmitter()\r\n ev.$on('fn1', ()=>console.log(1))\r\n ev.$on('fn2', ()=>console.log(2))\r\n ev.$emit('fn1')\r\n // 1\r\n ev.$emit('fn2')\r\n // 2\r\n ```\r\n */\r\nclass EventEmitter {\r\n    $cache = {};\r\n    $on(name, fn) {\r\n        if (this.$cache[name]) {\r\n            if (Array.isArray(this.$cache[name])) {\r\n                this.$cache[name].push(fn);\r\n            }\r\n            else {\r\n                this.$cache[name] = [fn];\r\n            }\r\n            return;\r\n        }\r\n        this.$cache[name] = [fn];\r\n    }\r\n    $off(name) {\r\n        if (!this.$cache[name])\r\n            return false;\r\n        delete this.$cache[name];\r\n        return true;\r\n    }\r\n    $once(name, ...args) {\r\n        if (this.$cache && this.$cache[name]) {\r\n            const result = this.$cache[name].map((i) => runFunc(i, ...args));\r\n            delete this.$cache[name];\r\n            return result;\r\n        }\r\n        return [];\r\n    }\r\n    // 创建副本，如果回调函数内继续注册相同事件，会造成死循环\r\n    $emit(name, ...args) {\r\n        if (!this.$cache[name])\r\n            return [];\r\n        return this.$cache[name].map((i) => runFunc(i, ...args));\r\n    }\r\n}\n\n/**\r\n * @title toFahrenheit\r\n * @description 摄氏度转换为华氏度\r\n * @param celsius {number}\r\n * @returns {number}\r\n * @version 2.4.0\r\n */\r\nconst toFahrenheit = (celsius) => celsius * 9 / 5 + 32;\r\n/**\r\n * @title toCelsius\r\n * @description 华氏度转换为摄氏度\r\n * @param fahrenheit {number}\r\n * @returns {number}\r\n * @version 2.4.0\r\n */\r\nconst toCelsius = (fahrenheit) => (fahrenheit - 32) * 5 / 9;\n\n/**\r\n * @title arrayToTree\r\n * @description 数组转树\r\n * @param array {object[]}\r\n * @param id {string}\r\n * @param pid {string}\r\n * @returns {object[]}\r\n * @version 2.4.1\r\n */\r\nfunction arrayToTree(array, id = 'id', pid = 'pid', child = 'children') {\r\n    const list = deepClone(array);\r\n    const result = [];\r\n    const temp = {};\r\n    // 先把全部id对应项 用temp 存起来\r\n    for (let i = 0; i < list.length; i++)\r\n        temp[list[i][id]] = list[i];\r\n    for (let k = 0; k < list.length; k++) {\r\n        if (temp[list[k][pid]] && list[k][id] !== list[k][pid]) {\r\n            if (!temp[list[k][pid]][child]) {\r\n                temp[list[k][pid]][child] = [];\r\n            }\r\n            temp[list[k][pid]][child].push(list[k]);\r\n        }\r\n        else\r\n            result.push(list[k]);\r\n    }\r\n    return result;\r\n}\n\nexport { EventEmitter, FileTypeMap, MapEntity, add, after, arrayToTree, ary, asyncBan, asyncThrowError, average, ban, before, between, bind, catchError, ceil, changeCase, chunk, clamp, concat, curry, dayOfYear, deadline, debounce, deepClone, delay, difference, divide, drop, dropRight, equal, existKeys, fill, filter, flat, flip, floor, format, getDecimal, hasOwn, hide, inRange, intervalDate, isArray, isAsyncFunction, isBigInt, isBoolean, isClient, isDate, isEffectNumber, isEmpty, isEqual, isEven, isExcelFile, isFile, isFileExtension, isFloat, isFunction, isIOS, isImageFile, isJsonString, isMap, isNumber, isObject, isOdd, isPdfFile, isPromise, isSameDate, isSet, isString, isSymbol, isTime, isVideoFile, isWindow, isWordFile, likeDate, likeFunction, likeNumber, logAsync, logGroup, loop, loopArray, loopArrays, loopGroup, loops, matchValue, max, maxBy, mean, meanBy, min, minBy, multiply, omitRecord, once, pick, random, replaces, reverseString, round, runFunc, select, selects, serialize, spLength, stringify, sum, sumBy, throttle, throwError, timezone, toArray, toCelsius, toDate, toFahrenheit, toFloat, toHEX, toNumber, toPathValue, toPromise, toString$1 as toString, toStrings, toThousands, type, types, unique, zip, zipObject };\n//# sourceMappingURL=index.esm.js.map\n","import { useState } from 'react'\r\nimport { isFunction, ObjectType } from 'abandonjs'\r\n\r\nexport function useSetState<T extends ObjectType>(initialState: T = {} as T)\r\n  : [T, (patch: Partial<T> | ((prevState: T) => Partial<T>)) => void] {\r\n\r\n  const [state, setState] = useState<T>(initialState)\r\n\r\n  return [\r\n    state,\r\n    (patch: Partial<T> | ((prevState: T) => Partial<T>)): void => {\r\n      if (isFunction(patch)) {\r\n        setState({ ...state, ...patch(state) })\r\n      } else {\r\n        setState({ ...state, ...patch })\r\n      }\r\n    }\r\n  ]\r\n}","import { useState } from 'react'\r\nimport { isNumber } from 'abandonjs'\r\n\r\nexport type Options = {\r\n\tmin?: number,\r\n\tmax?: number\r\n}\r\n\r\nfunction getTargetValue(val: number, options: Options = {}) {\r\n\tconst { min = 0, max = Infinity } = options;\r\n\tlet target = val;\r\n\tif (isNumber(max)) {\r\n\t\ttarget = Math.min(max, target)\r\n\t}\r\n\tif (isNumber(min)) {\r\n\t\ttarget = Math.max(min, target)\r\n\t}\r\n\treturn target;\r\n}\r\n\r\nexport function useCount(initialState: number, options: Options = {})\r\n\t: readonly [number, (value: number) => void] {\r\n\r\n\tconst [state, setStateTemp] = useState<number>(getTargetValue(initialState, options))\r\n\r\n\tconst setState = (value: number) => {\r\n\t\tconst result = getTargetValue(value, options)\r\n\t\tif (result === state) return;\r\n\t\tsetStateTemp(result)\r\n\t}\r\n\r\n\treturn [state, setState] as const\r\n}","import { useState, useCallback } from 'react';\r\n\r\nexport function useBoolean(initialState = true): [boolean, () => void] {\r\n\tconst [state, setState] = useState<boolean>(initialState)\r\n\r\n\treturn [\r\n\t\tstate,\r\n\t\tuseCallback(() => setState(state => !state), [])\r\n\t]\r\n}","import { useState } from 'react'\r\nimport { equal, ObjectType } from 'abandonjs'\r\n\r\ntype ObjectValue<UseObjectType = ObjectType> = UseObjectType[keyof UseObjectType]\r\n\r\ninterface Actions<ObjectValueType = ObjectType> {\r\n\tsetObject: (record: ObjectValueType) => void\r\n\tset: (key: keyof ObjectValueType, value: ObjectValue<ObjectValueType>, force?: boolean) => void\r\n\tremove: (key: keyof ObjectValueType) => void\r\n\treset: (force?: boolean) => void\r\n}\r\n\r\nexport function useObject<ObjectValueType = ObjectType>(initialValue?: ObjectValueType): [ObjectValueType, Actions<ObjectValueType>] {\r\n\r\n\tconst getInitialValue = () => initialValue || {} as ObjectValueType\r\n\r\n\tconst [state, setState] = useState<ObjectValueType>(() => getInitialValue())\r\n\r\n\tconst setObject = (record: ObjectValueType) => {\r\n\t\tif (equal(record, state)) return;\r\n\t\tsetState(record)\r\n\t}\r\n\r\n\tconst set = (key: keyof ObjectValueType, value: ObjectValue<ObjectValueType>, force = false) => {\r\n\t\tif (!force && equal(value, state[key])) return;\r\n\t\tconst tempState = { ...state }\r\n\t\ttempState[key] = value\r\n\t\tsetState(tempState)\r\n\t}\r\n\r\n\tconst remove = (key: keyof ObjectValueType) => {\r\n\t\tif (!Object.keys(state as ObjectType).includes(key as string)) return;\r\n\t\tconst tempState = { ...state }\r\n\t\tdelete tempState[key]\r\n\t\tsetState(tempState)\r\n\t}\r\n\r\n\tconst reset = (force = false) => {\r\n\t\tif (!force && equal(state, getInitialValue())) return;\r\n\t\tsetState(getInitialValue())\r\n\t}\r\n\r\n\treturn [state,\r\n\t\t{\r\n\t\t\tset,\r\n\t\t\tremove,\r\n\t\t\treset,\r\n\t\t\tsetObject\r\n\t\t}\r\n\t]\r\n}","import { useState } from 'react'\r\nimport { isEqual } from 'abandonjs'\r\n\r\ntype UseMapKey = string | number\r\n\r\ninterface Actions<Value> {\r\n\tset: (key: UseMapKey, value: Value, force?: boolean) => void\r\n\tsetAll: (newMap: Iterable<readonly [UseMapKey, Value]>, force?: boolean) => void\r\n\tremove: (key: UseMapKey) => void\r\n\treset: (force?: boolean) => void\r\n\tget: (key: UseMapKey) => Value | undefined\r\n}\r\n\r\nexport function useMap<Value>(initialValue?: Iterable<readonly [UseMapKey, Value]>): [Map<UseMapKey, Value>, Actions<Value>] {\r\n\r\n\tconst getInitialValue = () => initialValue === undefined ? new Map() : new Map(initialValue)\r\n\r\n\tconst [map, setMap] = useState<Map<UseMapKey, Value>>(() => getInitialValue())\r\n\r\n\tconst set = (key: UseMapKey, value: Value, force = false) => {\r\n\t\tif (isEqual(map.get(key), value) && !force) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tsetMap((prev) => {\r\n\t\t\tconst temp = new Map(prev)\r\n\t\t\ttemp.set(key, value)\r\n\t\t\treturn temp\r\n\t\t})\r\n\t}\r\n\r\n\tconst setAll = (newMap: Iterable<readonly [UseMapKey, Value]>) => {\r\n\t\tsetMap(new Map(newMap))\r\n\t}\r\n\r\n\tconst remove = (key: UseMapKey) => {\r\n\t\tsetMap((prev) => {\r\n\t\t\tconst temp = new Map(prev)\r\n\t\t\ttemp.delete(key)\r\n\t\t\treturn temp\r\n\t\t})\r\n\t}\r\n\r\n\tconst reset = () => setMap(getInitialValue())\r\n\r\n\tconst get = (key: UseMapKey) => map.get(key)\r\n\r\n\treturn [map, {\r\n\t\tset,\r\n\t\tsetAll,\r\n\t\tremove,\r\n\t\treset,\r\n\t\tget,\r\n\t}]\r\n}"],"names":[],"mappings":"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"}